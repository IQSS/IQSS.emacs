#+AUTHOR:  Ista Zahn
#+TITLE: An emacs config for social scientists
#+STARTUP: showall
#+PROPERTY: header-args:emacs-lisp    :tangle init.el


* What is this?
:PROPERTIES:
:CUSTOM_ID: what-is-this
:END:

This is an [[https://www.gnu.org/software/emacs/][Emacs]] configuration. There are many like it, but this one is mine. If you like it, make it yours! It provides lots of functionality while keeping things light and fast.

The main goal of this project is to provide an Emacs configuration that works more or less they way you would expect an editor or IDE to work in the second decade of the twenty-first century, without losing the things that make Emacs special. This is challenging because basic Emacs commands often conflict with de facto standards. Each of these conflicts is a judgment call; hopefully a good balance has been reached. 

Note that this documentation mostly uses Emacs notation for keybindings, e.g., =C= means "the Ctrl key", =M= means "the Meta (aka Alt) key", and =S= means "the Shift key". Refer to https://www.emacswiki.org/emacs/EmacsKeyNotation if you are not familiar with this notation.

Highlights of this Emacs configuration include:
- More standard select/copy/paste keys and right-click behavior makes it more familiar to those new to Emacs.
- Consistent and familiar code completion and indentation using the =tab= key.
- Consistent and familiar code evaluation using =C-ret= and =C-S-ret=.
- Literate programming configuration for running R, python, or other programming languages inside markdown or org-mode files.
- Powerful and simple search-based tools for finding commands, files and buffers, inserting citations etc.
- Convenient window management, including navigation with =C-x S-<arrow>=, and undo/redo with =C-c left= and =C-c right=.

The upshot is that if you have never used Emacs before many things will work as you expect; a few will not, in which case you will need to search the web or read the Emacs documentation to learn the Emacs way. You can launch a built-in tutorial by pressing =C-h t= (that's "Control+h, then t"), or read the getting started documentation at https://www.gnu.org/software/emacs/tour/. A cheat-sheet / survival guide is available at https://www.gnu.org/software/emacs/refcards/pdf/survival.pdf. 

If you are an Emacs user, most things will mostly work as you expect, though you may wish to familiarize yourself with the alternative "de facto standard" bindings configured here. The most glaring exception is the use of =C-v= to paste rather than scroll. My advice is to get in the habit of toggling read-only/view mode with =C-x C-q= (or =M-x read-only-mode=) when you need to do a lot of scrolling. In this mode =SPC= scrolls down and =S-SPC= scrolls up, just like it does in your web browser. When you must scroll down without toggling read-only mode you can use =Page Up= and =Page Down= (if your keyboard doesn't dedicated =Page Up= / =Page Down= keys try =Fn down= and =Fn up=). If you are an Emacs user and you find other key bindings that don't work as they should please open an issue in the [[https://github.com/izahn/dotemacs][github repo]].

A note for Mac users: the keybindings configured here use Windows-style. I wish I could make life easy for you by providing Mac style keyboard shortcuts, but that is simply too much work to be feasible. Basically this mostly boils down to "use the control key instead of the command key". For example, use "Control-q" to quit instead of "Command-q" as you do with other applications running on OS X.

* Quick start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

** How to I install it?
:PROPERTIES:
:CUSTOM_ID: how-do-i-install-it
:END:
1) Make sure emacs >= version 25.1 is installed on your computer. See [[file:UsefulPrograms.html][this list of useful programs]] for installation instructions.
2) Make sure you have [[http://git-scm.com/downloads][git]] installed on your computer. If you don't know what git is you might be interested in John McDonnell's [[http://nyuccl.org/pages/GitTutorial/][git tutorial]].
3) Determine your emacs configuration directory. Open emacs and type =C-x f ~/ RET=. This should open a directory listing buffer. Note the path at the top of this file. This is were your =s.d= should go.
4) Close Emacs.
5) Back up your existing =~/.emacs= file and =~/.emacs.d= directory (e.g., rename =.emacs= to =OLD.emacs= and rename =.emacs.d= to =OLD.emacs.d=).
6) Clone this repository into =~/.emacs.d= by opening a terminal and running =git clone http://github.com/izahn/dotemacs ~/.emacs.d=.

If you don't know how to use git, you can skip steps 2 and 6 and simply [[https://github.com/izahn/dotemacs/archive/master.zip][download the files as a zip archive]], extract them, and move them into your .emacs.d directory instead.

** First run
:PROPERTIES:
:CUSTOM_ID: first-run
:END:
Note that after installing this configuration emacs will be slow to start up the first time. This is due to package installation; just be patient and wait for it to finish--subsequent start-ups will be much faster.

** Important key bindings
:PROPERTIES:
:CUSTOM_ID: modified-key-bindings
:END:
This configuration loads a lot of useful emacs packages, many of which add key bindings. Documenting them all here would be too much (see the documentation for each package if you need the details), so this section describes only most important ones.

*** Common keyboard shortcuts

The most important keyboard shortcut in Emacs is =M-x=. This brings up a search-able list of all Emacs commands. In fact you could use this interface for everything and never bother learning any of the other keybindings listed below. For example, to open a file you could type =M-x counsel-find-file <ret>= instead of =C-o=. Nobody does this in practice, because =C=o= is easier. But if you can't remember the name of a keyboard shortcut don't worry: just type =M-x= and search for the command you need.

Other commonly used key bindings are listed in the table below.

| Key     | Description         | Notes                                                                   |
|---------+---------------------+-------------------------------------------------------------------------|
| C-o     | Open file           |                                                                         |
| C-w     | Close window        |                                                                         |
| C-q     | Quit                |                                                                         |
| S-arrow | Select a region     | =C-SPC arrow= does the same thing. =C-S-SPC= selects rectangular region |
| C-c     | Copy selection      |                                                                         |
| C-v     | Paste               |                                                                         |
| C-z     | Undo                | use =C-x U=  or =M-z= to visualize your undo/redo history               |
| S-C-z   | Redo                |                                                                         |
| C--     | Zoom out            |                                                                         |
| C-+     | Zoom in             |                                                                         |
| C-PgUp  | Beginning of buffer |                                                                         |
| C-PgDn  | End of buffer       |                                                                         |
|---------+---------------------+-------------------------------------------------------------------------|

Note that some things still work "the Emacs way". Notably:
- C-a :: Goes to the beginning of the line. To select all use =C-x h=. 
- C-s :: Searches. To save, use =C-x s=. 
- C-f :: Moves forward one character. To search use =C-s=.

*** Window management
One of the things that makes Emacs different that most other applications is the way that it handles windows. Unlike most Integrated Development Environments, there is no fixed layout. Instead, windows are created and killed as needed. New Emacs uses sometimes try to get Emacs to stop messing with their window layout -- my approach is to just let Emacs do what it wants and the revert the layout using =C-c left=.

Some other convenient window management keys are provided, in addition to the standard Emacs =C-x o= binding to navigate to "other window".

| Key              | Description                 | Notes                                                                          |
|------------------+-----------------------------+--------------------------------------------------------------------------------|
| C-x S-<arrow>    | Move to other window        |                                                                                |
| C-x S-0          | Move to a window by number  |                                                                                |
| C-c left         | Undo a window layout change |                                                                                |
| C-c right        | Redo a window layout change |                                                                                |
| C-c C-l <number> | Save/restore window layouts | This a somewhat advanced feature that lets you save and restore window layouts |
|------------------+-----------------------------+--------------------------------------------------------------------------------|

*** Searching and Completion
Utilities have been configured to make it easy to search by file name as well as to search the contents of files. Some of this functionality works much better if certain system utilities are found. See [[file:UsefulPrograms.html][this list of useful programs]], especially /everything/ (windows only) and /the silver searcher/ or /ripgrep/.

| Key     | Description                                | Notes                                                                            |
|---------+--------------------------------------------+----------------------------------------------------------------------------------|
| C-s     | Searches the current buffer using =swiper= |                                                                                  |
| C-S-s   | Searches files in the current directory    |                                                                                  |
| C-x S-f | (or *C-x O*) Searches by file name         | requires =mlocate= on linux, =everything= (http://www.voidtools.com/) on windows |
|---------+--------------------------------------------+----------------------------------------------------------------------------------|

Many standard Emacs keybindings have been replaced with versions that provide completion suggestions. In-buffer completion can be triggered with the =tab= key.

| Key   | Description                      | Notes                                                                               |
|-------+----------------------------------+-------------------------------------------------------------------------------------|
| tab   | Indent or complete               |                                                                                     |
| S-C-v | Paste from the clipboard history | M - S - y = also works for this                                                     |
| C-c r | Search for a reference to insert | You must set =bibtex-completion-bibliography= to your BibTeX files for this to work |
|-------+----------------------------------+-------------------------------------------------------------------------------------|

*** REPL interaction
This should be easy, and hopefully it is!

Aliases have been created for starting R, python, haskell, and terminals. For example, to start python just type =M-x python <ret>=.

To execute a line, region, or buffer from a script (R, python, bash) etc.) use the keybindings below.

| Key     | Description                          | Notes                                  |
|---------+--------------------------------------+----------------------------------------|
| C-RET   | Line/selection/expression evaluation | Works for R, python, shell, and others |
| S-C-RET | Buffer evaluation                    | Evaluate the whole script              |
|---------+--------------------------------------+----------------------------------------|

*** Other key bindings
:PROPERTIES:
:CUSTOM_ID: other-key-bindings
:END:

There are a few more odds-and-ends you might find useful:

- S-C-SPC :: Edit rectangular regions
- C-up / C-down :: Scroll up or down
- M-q :: Hard-wrap a paragraph
- M-S-Q :: Remove line breaks from a paragraph
- C-c C-o t :: Hide/show outline (outline-minor mode is enabled in programming modes and in LaTeX-mode)
- C-x cl :: Echo keybindings for tutorials. 
- C-c d :: Lookup word in dictionary.

Other key bindings can be discovered by =counsel-descbinds= (bound to =C-h b=) or via the menus.

** Interacting with external programs
 Many of the Emacs features configured here are designed to make it easier to interact with external programs. For example, [[http://ess.r-project.org][ESS]] makes it easy to interact with [[http://r-project.org][R]], and [[https://www.gnu.org/software/auctex/][AUCTEX]] makes it easy to interact with [[http://tug.org/texlive/][LaTeX]]. If you need help installing these programs, [[file:UsefullPrograms.org][this short guide]] may help. 


* Implementation
  :PROPERTIES:
  :CUSTOM_ID: implementation
  :END:

I used to have a long description about all the packages this configuration sets up, but showing you the actual code is better. Each section starts with a description of what it does, followed by the code that implements it.

** Version check and preparation
   :PROPERTIES:
   :CUSTOM_ID: version-check
   :END:
It is difficult to support multiple versions of emacs, so we will pick an arbitrary cutoff and throw an error if the version of emacs is "too old".

#+BEGIN_SRC emacs-lisp
  (when (< (string-to-number 
             (concat 
              (number-to-string emacs-major-version) 
              "." 
              (number-to-string emacs-minor-version)))
            25.1)
    (error "Your version of emacs is very old and must be upgraded before you can use these packages!"))

  ;; set coding system so emacs doesn't choke on melpa file listings
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (unless (eq system-type 'windows-nt)
    (set-selection-coding-system 'utf-8))
  (prefer-coding-system 'utf-8)
  (setq buffer-file-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

  (require 'cl)

  ;; set things that need to be set before packages load
  (setq outline-minor-mode-prefix "\C-c\C-o")
  (add-hook 'outline-minor-mode-hook
            (lambda () (local-set-key "\C-c\C-o"
                                      outline-mode-prefix-map)))
  (setq save-abbrevs 'silently)
#+END_SRC

** Install useful packages
   :PROPERTIES:
   :CUSTOM_ID: install-useful-packages
   :END:
The main purpose of these emacs configuration files is to install and configure useful emacs packages. Here we carry out the installation.

#+BEGIN_SRC emacs-lisp
  ;; load the package manager
  (require 'package)
  (package-initialize t)

  ;; Add additional package sources
  (add-to-list 'package-archives 
               '("melpa" . "http://melpa.milkbox.net/packages/") t)

  ;; Make a list of the packages you want
  (setq package-selected-packages
        '(;; gnu packages
          auctex
          windresize
          diff-hl
          adaptive-wrap
          ;; melpa packages
          mode-icons
          command-log-mode
          undo-tree
          better-defaults
          diminish
          dired+
          ace-window
          howdoi
          auctex-latexmk
          multi-term
          with-editor
          git-commit
          magit
          eyebrowse
          mouse3
          swiper
          counsel
          flx-ido
          smex
          ivy-bibtex
          hydra
          ivy-hydra
          which-key
          outline-magic
          smooth-scroll
          unfill
          company
          company-math
          company-auctex
          ess
          markdown-mode
          polymode
          eval-in-repl
          haskell-mode
          ghc
          company-ghci
          flycheck
          scala-mode
          ensime
          sbt-mode
          exec-path-from-shell
          htmlize
          sdcv ;; stardictionary
          osx-dictionary
          define-word
          ox-pandoc
          untitled-new-buffer))
  ;; install packages if needed
  (unless (every 'package-installed-p package-selected-packages)
    (package-refresh-contents)
    ;; org needs to be installed first
    (package-install (cadr (assq 'org package-archive-contents)))
    (package-install-selected-packages))
  (package-initialize)
#+END_SRC

** Add custom lisp directory to load path
   :PROPERTIES:
   :CUSTOM_ID: add-custom-lisp-directory-to-load-path
   :END:
We try to install most things using the package manager, but a few things need to be included in a custom lisp directory. Add it to the path so we can load from it easily.
#+BEGIN_SRC emacs-lisp
  ;; add custom lisp directory to path
  (let ((default-directory (concat user-emacs-directory "lisp/")))
    (setq load-path
          (append
           (let ((load-path (copy-sequence load-path))) ;; Shadow
             (append 
              (copy-sequence (normal-top-level-add-to-load-path '(".")))
              (normal-top-level-add-subdirs-to-load-path)))
           load-path)))

  ;; on OSX Emacs needs help setting up the system paths
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))
#+END_SRC

#+RESULTS:

** Tweak default Emacs settings
   :PROPERTIES:
   :CUSTOM_ID: miscellaneous
   :END:

This section sets up various utilities and conveniences. Many of these are low priority, so we set them first in order to allow any conflicting settings to be overridden later.

#+BEGIN_SRC emacs-lisp
  ;; better defaults are well, better... but we don't always agree
  (menu-bar-mode 1)
  (scroll-bar-mode 1)

  ;; scrolling behavior
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
  (setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ; scroll window under mouse
  (setq scroll-preserve-screen-position t)
  (setq scroll-conservatively 100000)

  ;; Use y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  (transient-mark-mode 1) ; makes the region visible
  (line-number-mode 1)    ; makes the line number show up
  (column-number-mode 1)  ; makes the column number show up

  ;; smooth horizontal scrolling
  (global-set-key [(control down)] 'scroll-up-1)
  (global-set-key [(control up)] 'scroll-down-1)
  (global-set-key [(control left)] 'scroll-right-1)
  (global-set-key [(control right)] 'scroll-left-1)

  ;; make home and end behave
  (global-set-key (kbd "<home>") 'move-beginning-of-line)
  (global-set-key (kbd "<end>") 'move-end-of-line)

  ;; enable toggling paragraph un-fill
  (define-key global-map "\M-Q" 'unfill-paragraph)

  ;;; line wrapping
  ;; neck beards be damned, we don't need to hard wrap. The editor can soft wrap for us.
  (remove-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'visual-line-mode-hook 'adaptive-wrap-prefix-mode)
  (add-hook 'text-mode-hook 'visual-line-mode 1)
  (add-hook 'prog-mode-hook
            (lambda()
              (toggle-truncate-lines t)
                (outline-minor-mode t)))

  ;; indicate visual-line-mode wrap
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
  ;; but be gentle
  (defface visual-line-wrap-face
  '((t (:foreground "gray")))
  "Face for visual line indicators.")
  (set-fringe-bitmap-face 'left-curly-arrow 'visual-line-wrap-face)
  (set-fringe-bitmap-face 'right-curly-arrow 'visual-line-wrap-face)

  ;; don't require two spaces for sentence end.
  (setq sentence-end-double-space nil)

  ;; The beeping can be annoying--turn it off
  (set-variable 'visible-bell t)

  ;; save place -- move to the place I was last time I visited this file
  (save-place-mode t)

  ;; easy navigation in read-only buffers
  (setq view-read-only t)
  (with-eval-after-load "view-mode"
    (define-key view-mode-map (kbd "s") 'swiper))

#+END_SRC

** Make Emacs friendlier to newcomers
Emacs will never to as simple as Notepad, but perhaps it can be made more consistent with the way most other programs behave.

#+BEGIN_SRC emacs-lisp
  ;; Use CUA mode to make life easier. We _do_ use standard copy/paste etc. 
  (cua-mode t)

  ;; (cua-selection-mode t) ;; uncomment this to get cua goodness without copy/paste etc.

  ;; make control-q quit
  (global-set-key (kbd "C-q") 'save-buffers-kill-terminal)

  ;; make control-w close window
  (global-set-key (kbd "C-w") 'delete-window)
  (define-key cua--region-keymap (kbd "C-w") 'cua-cut-region)

  ;; new buffer (not quite what you expect, but we emacs users need C-n
  (setq untitled-new-buffer-major-modes '(text-mode r-mode python-mode LaTeX-mode markdown-mode org-mode))
  (global-set-key (kbd "C-S-n") 'untitled-new-buffer-with-select-major-mode)

  ;; ;; Make control-z undo
  (global-undo-tree-mode t)
  (global-set-key (kbd "C-z") 'undo)
  (define-key undo-tree-map (kbd "C-S-z") 'undo-tree-redo)
  (define-key undo-tree-map (kbd "C-x u") 'undo)
  (define-key undo-tree-map (kbd "C-x U") 'undo-tree-visualize)
  (define-key undo-tree-map (kbd "M-z") 'undo-tree-visualize)
  ;; Make C-g quit undo tree
  (define-key undo-tree-visualizer-mode-map (kbd "C-g") 'undo-tree-visualizer-quit)
  (define-key undo-tree-visualizer-mode-map (kbd "<escape> <escape> <escape>") 'undo-tree-visualizer-quit)

  ;;
  ;; Make right-click do something close to what people expect
  (global-set-key (kbd "<mouse-3>") 'mouse3-popup-menu)
  ;; (global-set-key (kbd "C-f") 'isearch-forward)
  ;; (global-set-key (kbd "C-s") 'save-buffer)
  ;; (global-set-key (kbd "C-o") 'counsel-find-file)
  (define-key cua-global-keymap (kbd "<C-S-SPC>") nil)
  (define-key cua-global-keymap (kbd "<C-return>") nil)
  (setq cua-rectangle-mark-key (kbd "<C-S-SPC>"))
  (define-key cua-global-keymap (kbd "<C-S-SPC>") 'cua-rectangle-mark-mode)

  ;; nicer mode line
  (mode-icons-mode)

  ;; zoom in/out like we do everywhere else.
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)

  ;; page up/down
  (global-set-key (kbd "<C-prior>") 'beginning-of-buffer)
  (global-set-key (kbd "<C-next>") 'end-of-buffer)
#+END_SRC

** Window Management
   :PROPERTIES:
   :CUSTOM_ID: window-management
   :END:

=windmove= allows you to move point to adjacent windows; these functions are bound to =C-x S-<arrow>=. For example, to move to the window below, press "Control-x shift-down", and to move to the window to the right press "Control-x shift-right". Finally, you can use =C-x O= to quickly navigate to an window arbitrary window (e.g., diagonal from the current window).

=winner-mode= allows you to undo/redo window configuration changes. Use =C-c <left>= to undo and =C-c <right>= to redo.

Emacs has [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Configuration-Registers.html#Configuration-Registers][window layout management]], built-in but it's not convenient to use. [[https://github.com/wasamasa/eyebrowse][Eyebrowse]] makes it easier, so we use that. Create a new layout with =C-c C-l C-n=, switch with =C-c C-l #= .

#+BEGIN_SRC emacs-lisp
  ;; Work spaces
  (setq eyebrowse-keymap-prefix (kbd "C-c C-l"))
  (eyebrowse-mode t)

  ;; Undo/redo window changes
  (winner-mode 1)

  ;; windmove 
  (global-set-key (kbd "C-x <S-left>") 'windmove-left)
  (global-set-key (kbd "C-x <S-right>") 'windmove-right)
  (global-set-key (kbd "C-x <S-up>") 'windmove-up)
  (global-set-key (kbd "C-x <S-down>") 'windmove-down)

  ;; use ace-window for navigating windows
  (global-set-key (kbd "C-x O") 'ace-window)
  (with-eval-after-load "ace-window"
    (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+END_SRC

** Spell checking and dictionaries
   :PROPERTIES:
   :CUSTOM_ID: spell-checking
   :END:

Emacs comes with spell checking built-in, it just needs to be turned on. By default automatic spell checking is enabled in =text-mode= and =prog-mode= buffers. You can also spell-check on demand with =ispell-word=, bound to =M-$=. Finally, dictionaries look-up is available and bound to =C-c d=.

More information is available at https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html and https://github.com/abo-abo/define-word.

#+BEGIN_SRC emacs-lisp
  ;; enable on-the-fly spell checking
  (add-hook 'text-mode-hook
            (lambda ()
              (flyspell-mode 1)))
  ;; prevent flyspell from finding mistakes in the code
  (add-hook 'prog-mode-hook
            (lambda ()
              ;; `ispell-comments-and-strings'
              (flyspell-prog-mode)))

  ;; ispell should not check code blocks in org mode
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+begin_example " . "#\\+end_example$"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE " . "#\\+END_EXAMPLE$"))

  ;; Dictionaries

  ;; default in case we don't find something local
  (global-set-key (kbd "C-c d") 'define-word-at-point)
  (global-set-key (kbd "C-c S-D") 'define-word)

  ;; use dictionary app on os x
  (when (memq window-system '(mac ns))
    (global-set-key (kbd "C-c d") 'osx-dictionary-search-word-at-point)
    (global-set-key (kbd "C-c S-D") 'osx-dictionary-search-input))

  ;; Use stardict if we find a usable interface
  (when (executable-find "sdcv")
    (require 'sdcv)
    (global-set-key (kbd "C-c d") 'sdcv-search-input)
    (global-set-key (kbd "C-c S-D") 'sdcv-search-pointer+)
    (add-hook 'sdcv-mode-hook
              '(lambda()
                 (setq-local font-lock-string-face 'default))))
#+END_SRC

** Printing
   :PROPERTIES:
   :CUSTOM_ID: printing
   :END:
If you're using [[http://vgoulet.act.ulaval.ca/en/emacs/windows/][Vincent Goulet's emacs]] on Windows printing should work out of the box. If you're on Linux or Mac the experience of printing from emacs may leave something to be desired. Here we try to make it work a little better by making it easier to preview buffers in a web browser (you can print from there as usual) and by using [[http://sourceforge.net/projects/gtklp/][gtklp]] on Linux if it is available.

#+BEGIN_SRC emacs-lisp

  (when (eq system-type 'gnu/linux)
    (setq hfyview-quick-print-in-files-menu t)
    (require 'hfyview)
    (setq mygtklp (executable-find "gtklp"))
    (when mygtklp
      (setq lpr-command "gtklp")
      (setq ps-lpr-command "gtklp")))

  (when (eq system-type 'darwin)
    (setq hfyview-quick-print-in-files-menu t)
    (require 'hfyview))
#+END_SRC

** Minibuffer hints and completion
   :PROPERTIES:
   :CUSTOM_ID: minibuffer-hints-and-completion
   :END:
There are several different systems for providing completion hints in emacs. The default pcomplete system shows completions on demand (usually bound to tab key) in an emacs buffer. Here we set up ivy, which instead shows these completions on-the-fly in the minibuffer. These completions are primarily used to show available files (e.g., with ~find-file~) and emacs functions (e.g., with ~execute-extended-command~). More information is available at http://oremacs.com/swiper/.

Note that completion for in-buffer text (e.g., methods in python-mode, or arguments in R-mode) are handled separately by [[#auto-complete-configuration][company-mode]].

#+BEGIN_SRC emacs-lisp
  (ivy-mode 1)

  (setq counsel-find-file-ignore-regexp "\\`\\.")
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-display-style nil)

  ;; Ivy-based interface to standard commands
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "C-r") 'swiper)
  ;; Search files in directory with C-S
  (global-set-key (kbd "C-S-s") 'find-grep-dired); default if we don't find something better
  (cond
   ((executable-find "rg") ; search with ripgrep if we have it
    (global-set-key (kbd "C-S-s") 'counsel-rg))
   ((executable-find "ag") ; otherwise search with ag if we have it
    (global-set-key (kbd "C-S-s") 'counsel-ag))
   ((executable-find "pt") ; otherwise search with pt if we have it
    (global-set-key (kbd "C-S-s") 'counsel-pt)))
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "M-y") 'counsel-yank-pop)
  (global-set-key (kbd "C-S-v") 'counsel-yank-pop)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "C-o") 'counsel-find-file)
  ;; search for files to open with "C-O=
  (when (memq window-system '(mac ns)) ; use mdfind on Mac. TODO: what about windows?
    (setq locate-command "mdfind")
    (setq counsel-locate-cmd 'counsel-locate-cmd-mdfind))
  (global-set-key (kbd "C-x C-S-F") 'find-name-dired) ; default in case we don't have something better
  (global-set-key (kbd "C-x C-S-F") 'counsel-locate)
  (global-set-key (kbd "C-S-O") 'counsel-locate)
  (global-set-key (kbd "C-x C-r") 'counsel-recentf)
  (global-set-key (kbd "<C-tab>") 'counsel-company)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-load-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  ;; Ivy-based interface to shell and system tools
  (global-set-key (kbd "C-c g") 'counsel-git)
  (global-set-key (kbd "C-c j") 'counsel-git-grep)
  (global-set-key (kbd "C-c k") 'counsel-ag)
  (global-set-key (kbd "C-x l") 'counsel-locate)
  (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
  ;; Ivy-resume and other commands

  (global-set-key (kbd "C-c i") 'ivy-resume)

  ;; Make Ivy more like ido
  (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done)
  (define-key ivy-minibuffer-map (kbd "C-d") 'ivy-done)
  (define-key ivy-minibuffer-map (kbd "C-b") 'ivy-immediate-done)
  (define-key ivy-minibuffer-map (kbd "C-f") 'ivy-immediate-done)

  ;; show recently opened files
  (setq recentf-max-menu-items 50)
  (recentf-mode 1)

#+END_SRC

** Auto-complete configuration
   :PROPERTIES:
   :CUSTOM_ID: auto-complete-configuration
   :END:
Here we configure in-buffer text completion using the company-mode package. These completions are available on-demand using =tab= for in-buffer popup or =C-tab= for search-able minibuffer list. More information is available at https://company-mode.github.io/.

#+BEGIN_SRC emacs-lisp
  (require 'company)
  ;; cancel if input doesn't match, be patient, and don't complete automatically.
  (setq company-require-match nil
        company-async-timeout 6
        company-idle-delay nil
        company-global-modes '(not term-mode))
  ;; complete using C-tab
  (global-set-key (kbd "<C-tab>") 'counsel-company)
  ;; use C-n and C-p to cycle through completions
  ;; (define-key company-mode-map (kbd "<tab>") 'company-complete)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "<tab>") 'company-complete-common)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-active-map (kbd "<backtab>") 'company-select-previous)

  (require 'company-capf)
  ;; put company-capf and company-files at the beginning of the list
  (setq company-backends
        '(company-files company-capf company-nxml company-css company-cmake company-semantic company-clang company-xcode company-eclim))
  (setq-default company-backends
                '(company-files company-capf company-nxml company-css company-cmake company-semantic company-clang company-xcode company-eclim))

  ;;Use tab to complete.
  ;; See https://github.com/company-mode/company-mode/issues/94 for another approach.

  ;; this is a copy-paste from the company-package with extra conditions to make
  ;; sure we don't offer completions in the middle of a word.

  (defun my-company-indent-or-complete-common ()
    "Indent the current line or region, or complete the common part."
    (interactive)
    (cond
     ((use-region-p)
      (indent-region (region-beginning) (region-end)))
     ((and (not (looking-at "\\w\\|\\s_"))
           (memq indent-line-function
                 '(indent-relative indent-relative-maybe)))
      (company-complete-common))
     ((let ((old-point (point))
            (old-tick (buffer-chars-modified-tick))
            (tab-always-indent t))
        (call-interactively #'indent-for-tab-command)
        (when (and (eq old-point (point))
                   (eq old-tick (buffer-chars-modified-tick))
                   (not (looking-at "\\w\\|\\s_")))
          (company-complete-common))))))

  (define-key company-mode-map (kbd "<tab>") 'my-company-indent-or-complete-common)

  ;; not sure why this should be set in a hook, but that is how the manual says to do it.
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Which-key
   :PROPERTIES:
   :CUSTOM_ID: which-key
   :END:

This mode shows a keymap when an incomplete command is entered. It is especially useful for families of commands with a prefix, e.g., =C-c C-o= for =outline-mode= commands, or =C-c C-v= for =org-babel= commands. Just start typing your command and pause if you want a hint.

#+BEGIN_SRC emacs-lisp
;; (require 'which-key)
(which-key-mode)
#+END_SRC

** Flycheck
Provides on-the-fly syntax checking. Depends on external tools, e.g, [[https://cran.rstudio.com/web/packages/lintr/index.html][lintr]] for R code, [[https://flake8.readthedocs.io/en/latest/][flake8]] for python. See http://www.flycheck.org/en/latest/languages.html#flycheck-languages for supported languages and tools.

Note that active on-the-fly syntax checking is _disabled_ by default since I find it too annoying. You can still use =flycheck= to check your syntax on demand using =flycheck-compile=, and you can enable on-the-fly checking with =M-x flycheck-mode=.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)
  ;; (global-flycheck-mode)
#+END_SRC

** Outline-magic
   :PROPERTIES:
   :CUSTOM_ID: outline-magic
   :END:
I encourage you to use [[*Note taking and outlining (Org-mode)][org-mode]] for note taking and outlining, but it can be convenient to treat arbitrary buffers as outlines. The outline-magic mode can help with that.

#+BEGIN_SRC emacs-lisp
  ;;; Configure outline minor modes
  ;; Less crazy key bindings for outline-minor-mode
  (setq outline-minor-mode-prefix "\C-c\C-o")
  ;; load outline-magic along with outline-minor-mode
  (add-hook 'outline-minor-mode-hook 
            (lambda () 
              (require 'outline-magic)
              (define-key outline-minor-mode-map "\C-c\C-o\t" 'outline-cycle)))
#+END_SRC

** Major modes configuration
   :PROPERTIES:
   :CUSTOM_ID: major-modes-configuration
   :END:


*** General REPL (comint) config
    :PROPERTIES:
    :CUSTOM_ID: general-repl-config
    :END:

Many programs using REPLs are derived from =comint-mode=, so we can affect all of them by changing =comint-mode= settings. Here we disable line wrapping and ask programs to echo the input.

Load eval-in-repl for bash, elisp, and python interaction.
#+BEGIN_SRC emacs-lisp
  ;; require the main file containing common functions
  (require 'eval-in-repl)
  (setq comint-process-echoes t)

  ;; truncate lines in comint buffers
  (add-hook 'comint-mode-hook
            (lambda()
              (setq truncate-lines 1)))

  ;; Scroll down for input and output
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)
#+END_SRC

*** Run R in emacs (ESS)
    :PROPERTIES:
    :CUSTOM_ID: run-r-in-emacs
    :END:

Support for R in Emacs is good, thanks to http://ess.r-project.org/. As with other programming languages this configuration enables completion via the =tab= key and code evaluation with =C-ret=. Many more features are provided by ESS, refer to http://ess.r-project.org/ for details.

#+BEGIN_SRC emacs-lisp
  ;;;  ESS (Emacs Speaks Statistics)

  ;; Start R in the working directory by default
  (setq ess-ask-for-ess-directory nil)

  ;; Make sure ESS is loaded before we configure it
  (autoload 'julia "ess-julia" "Start a Julia REPL." t)
  (with-eval-after-load "ess-site"
    ;; see https://github.com/emacs-ess/ESS/pull/390 for ideas on how to integrate tab completion
    ;; disable ehoing input
    (setq ess-eval-visibly nil)
    ;; Start R in the working directory by default
    (setq ess-ask-for-ess-directory nil)
    ;; Use tab completion
    (setq ess-tab-complete-in-script t)
    ;; extra ESS stuff inspired by https://github.com/gaborcsardi/dot-emacs/blob/master/.emacs
    (ess-toggle-underscore nil)
    (defun my-ess-execute-screen-options (foo)
      "cycle through windows whose major mode is inferior-ess-mode and fix width"
      (interactive)
      (setq my-windows-list (window-list))
      (while my-windows-list
        (when (with-selected-window (car my-windows-list) (string= "inferior-ess-mode" major-mode))
          (with-selected-window (car my-windows-list) (ess-execute-screen-options t)))
        (setq my-windows-list (cdr my-windows-list))))
    (add-to-list 'window-size-change-functions 'my-ess-execute-screen-options)
    (define-key ess-mode-map (kbd "<C-return>") 'ess-eval-region-or-function-or-paragraph-and-step)
    (define-key ess-mode-map (kbd "<C-S-return>") 'ess-eval-buffer)
    ;; truncate long lines in R source files
    (add-hook 'ess-mode-hook
              (lambda()
                ;; don't wrap long lines
                (toggle-truncate-lines t)
                (outline-minor-mode t)))
    ;; highlight function calls and operators
    (setq ess-R-font-lock-keywords
          (quote
           ((ess-R-fl-keyword:modifiers)
            (ess-R-fl-keyword:fun-defs . t)
            (ess-R-fl-keyword:keywords . t)
            (ess-R-fl-keyword:assign-ops . t)
            (ess-R-fl-keyword:constants . 1)
            (ess-fl-keyword:fun-calls . t)
            (ess-fl-keyword:numbers)
            (ess-fl-keyword:operators . t)
            (ess-fl-keyword:delimiters)
            (ess-fl-keyword:=)
            (ess-R-fl-keyword:F&T)
            (ess-R-fl-keyword:%op% . t)))))
#+END_SRC

*** Run python in emacs (python-mode)
    :PROPERTIES:
    :CUSTOM_ID: run-python-in-emacs
    :END:

Emacs has decent python support out of the box. As with other programming languages you can get completion suggestions with the =tab= key, and evaluate code with =C-ret=. Many more features are provided and are accessible via the menu.

#+BEGIN_SRC emacs-lisp
  (defalias 'python 'run-python)
  (with-eval-after-load "python"
    ;; try to get indent/completion working nicely
    (setq python-indent-trigger-commands '(my-company-indent-or-complete-common indent-for-tab-command yas-expand yas/expand))
    ;; readline support is wonky at the moment
    (setq python-shell-completion-native-enable nil)
    ;; simple evaluation with C-ret
    (require 'eval-in-repl-python)
    (define-key python-mode-map (kbd "C-c C-c") 'eir-eval-in-python)
    (define-key python-mode-map (kbd "<C-return>") 'eir-eval-in-python)
    (define-key python-mode-map (kbd "C-c C-b") 'python-shell-send-buffer)
    (define-key python-mode-map (kbd "<C-S-return>") 'python-shell-send-buffer))
#+END_SRC

*** emacs lisp REPL (ielm)
    :PROPERTIES:
    :CUSTOM_ID: emacs-lisp-repl
    :END:

If you want to get the most out of Emacs, you'll eventually need to learn a little Emacs-lisp. This configuration helps by providing a standard =C-ret= evaluation key binding, and by providing completion with the =tab= key.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "elisp-mode"
    (require 'company-elisp)
    ;; ielm
    (require 'eval-in-repl-ielm)
    ;; For .el files
    (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eir-eval-in-ielm)
    (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
    (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)
    (define-key emacs-lisp-mode-map (kbd "<C-S-return>") 'eval-buffer)
    ;; For *scratch*
    (define-key lisp-interaction-mode-map "\C-c\C-c" 'eir-eval-in-ielm)
    (define-key lisp-interaction-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
    (define-key lisp-interaction-mode-map (kbd "C-c C-b") 'eval-buffer)
    (define-key lisp-interaction-mode-map (kbd "<C-S-return>") 'eval-buffer)
    ;; For M-x info
    (define-key Info-mode-map (kbd "C-c C-c") 'eir-eval-in-ielm)
    ;; Set up completions
    (add-hook 'emacs-lisp-mode-hook
              (lambda()
                ;; make sure completion calls company-elisp first
                (require 'company-elisp)
                (setq-local company-backends
                            (delete-dups (cons 'company-elisp (cons 'company-files company-backends)))))))
#+END_SRC

*** Haskell mode
    :PROPERTIES:
    :CUSTOM_ID: light-weight-markup-language
    :END:
I just recently started learning Haskell. There's not much to the configuration at this point, but you should get completion with =tab=.

#+BEGIN_SRC emacs-lisp
  (defalias 'haskell 'haskel-interactive-bring)
  (require 'company-ghci)
  (add-hook 'haskell-mode-hook (lambda ()
                                 (setq-local company-backends
                                             (delete-dups (cons 'company-ghci (cons 'company-files company-backends))))))
  (add-hook 'haskell-interactive-mode-hook 'company-mode)
#+END_SRC

*** Light-weight markup language (Markdown mode)
    :PROPERTIES:
    :CUSTOM_ID: light-weight-markup-language
    :END:

Markdown is a light-weight markup language that makes easy things easy and stays out of your way. You can export Markdown documents to a wide range of formats including .pdf (via latex), .html, .doc, and more using =pandoc=. For more information about authoring markdown in Emacs refer to http://jblevins.org/projects/markdown-mode/. For information about Markdown syntax or exporting to other formats refer to http://pandoc.org.

#+BEGIN_SRC emacs-lisp
  ;; Use markdown-mode for files with .markdown or .md extensions
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

*** Typesetting markup (AucTeX)
    :PROPERTIES:
    :CUSTOM_ID: typesetting-markup
    :END:
I don't write nearly as much in LaTeX as I used to, as Markdown and/or Org mode are simpler and good enough for my needs. But LaTeX is still the tool of choice for much academic writing, so we use AUCTEX and turn on lots of features. Completion of math and latex commands is available with =tab=, and auto-compile is available with =C-ret=.

  See https://www.gnu.org/software/auctex/ for more details about AUCTEX. 

#+BEGIN_SRC emacs-lisp
  ;; AucTeX config
  (with-eval-after-load "Latex"
    ;; Easy compile key
    (define-key LaTeX-mode-map (kbd "<C-return>") 'TeX-command-run-all)
    ;; Allow paragraph filling in tables
    (setq LaTeX-indent-environment-list
          (delq (assoc "table" LaTeX-indent-environment-list)
                LaTeX-indent-environment-list))
    (setq LaTeX-indent-environment-list
          (delq (assoc "table*" LaTeX-indent-environment-list)
                LaTeX-indent-environment-list))
    ;; Misc. latex settings
    (setq TeX-parse-self t
          TeX-auto-save t)
    (setq-default TeX-master nil)
    ;; Add beamer frames to outline list
    (setq TeX-outline-extra
          '((".*\\\\begin{frame}\n\\|.*\\\\begin{frame}\\[.*\\]\\|.*\\\\begin{frame}.*{.*}\\|.*[       ]*\\\\frametitle\\b" 3)))
    ;; reftex settings
    (setq reftex-enable-partial-scans t)
    (setq reftex-save-parse-info t)
    (setq reftex-use-multiple-selection-buffers t)
    (setq reftex-plug-into-AUCTeX t)
    (add-hook 'TeX-mode-hook
              (lambda ()
                (turn-on-reftex)
                (TeX-PDF-mode t)
                (LaTeX-math-mode)
                (TeX-source-correlate-mode t)
                (imenu-add-to-menubar "Index")
                (outline-minor-mode)
                (require 'company-math)
                (require 'company-auctex)
                (company-auctex-init)
                (setq-local company-backends (delete-dups
                                              (cons '(company-math-symbols-latex
                                                      company-auctex-macros
                                                      company-auctex-environments)
                                                    (cons 'company-files company-backends))))))    
    (add-hook 'bibtex-mode-hook
              (lambda ()
                (define-key bibtex-mode-map "\M-q" 'bibtex-fill-entry))))
#+END_SRC


*** Citations (ivy-bibtex)
This allows you to search your BibTeX files for references to insert into the current document. For it to work you will need to set `bibtex-completion-bibliography` to the location of your BibTeX files.

Initiate a citation search with =ivy-bibtex=, bound to =C-c r=.

See https://github.com/tmalsburg/helm-bibtex for information about reading attached .pdf files, searching online bibliography sources and more.

#+BEGIN_SRC emacs-lisp
  (setq ivy-bibtex-default-action 'ivy-bibtex-insert-citation)
  (global-set-key (kbd "C-c r") 'ivy-bibtex)
#+END_SRC
*** Note taking and outlining (Org-mode)
    :PROPERTIES:
    :CUSTOM_ID: note-taking-and-outlining
    :END:

Org mode is a powerful markup-language native to Emacs. It can be compared to markdown, but it has many more features. I use it for note taking a preparing lecture materials, but people use it for all kinds of things, from TODO lists to project planning to authoring academic papers. The settings below try to make Org mode play nicely with other packages, and enable many of the literate programming features. More information about Org mode can be found at [[http://orgmode.org]]. 

#+BEGIN_SRC emacs-lisp 
  (with-eval-after-load "org"
    ;; no compay mode in org buffers
    (add-hook 'org-mode-hook (lambda() (company-mode -1)))
    (setq org-replace-disputed-keys t)
    (setq org-support-shift-select t)
    (setq org-export-babel-evaluate nil)
    ;; (setq org-startup-indented t)
    ;; increase imenu depth to include third level headings
    (setq org-imenu-depth 3)
    ;; Set sensible mode for editing dot files
    (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
    ;; Update images from babel code blocks automatically
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    ;; configure org-mode when opening first org-mode file
    ;; Load additional export formats
    (require 'ox-ascii)
    (require 'ox-md)
    (require 'ox-html)
    (require 'ox-latex)
    (require 'ox-odt)

    (require 'org-capture)
    (require 'org-protocol)

    ;; Enable common programming language support in org-mode
    (require 'ob-shell)
    (require 'ob-emacs-lisp)
    (require 'ob-org)
    (when (executable-find "R") 
        (require 'ess-site)
        (require 'ob-R))
    (when (executable-find "python") (require 'ob-python))
    (when (executable-find "matlab") (require 'ob-matlab))
    (when (executable-find "octave") (require 'ob-octave))
    (when (executable-find "perl") (require 'ob-perl))
    (when (executable-find "dot") (require 'ob-dot))
    (when (executable-find "ditaa") (require 'ob-ditaa))

    ;; Fontify code blocks in org-mode
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil))

#+END_SRC

*** Multiple modes in one "buffer" (polymode)
    :PROPERTIES:
    :CUSTOM_ID: multiple-modes-in-one-buffer
    :END:

Emacs uses different /modes/ for different kinds of files and buffers. This is what makes is possible to have one set of behaviors when editing LaTeX, and a different set of behaviors when writing R code. But what if we want to do both, in the same file? Then we need to have multiple modes, in the same buffer, and we can thanks to [[https://github.com/vspinu/polymode][polymode]]. 

#+BEGIN_SRC emacs-lisp
  ;;; polymode
  ;; polymode requires emacs >= 24.3, does not work on the RCE. 
  (when (>= (string-to-number 
             (concat 
              (number-to-string emacs-major-version) 
              "." 
              (number-to-string emacs-minor-version)))
            24.3)
    ;; Activate polymode for files with the .md extension
    (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
    ;; Activate polymode for R related modes
    (add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
    (add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
    (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode))
    (add-to-list 'auto-mode-alist '("\\.rapport" . poly-rapport-mode))
    (add-to-list 'auto-mode-alist '("\\.Rhtml" . poly-html+r-mode))
    (add-to-list 'auto-mode-alist '("\\.Rbrew" . poly-brew+r-mode))
    (add-to-list 'auto-mode-alist '("\\.Rcpp" . poly-r+c++-mode))
    (add-to-list 'auto-mode-alist '("\\.cppR" . poly-c++r-mode))
    ;; polymode doesn't play nice with adaptive-wrap, turn it off
    (add-hook 'polymode-init-host-hook
              '(lambda()
                 (adaptive-wrap-prefix-mode -1)
                 (electric-indent-mode -1)
                 (unless (featurep 'ess-site)
                   (require 'ess-site)))))
#+END_SRC

*** Email (mu4e)
Not everyone wants to read email in Emacs, but you can if you want. The settings below configure some basic things, but you will need additional configuration to set up your email accounts. See the [[http://www.djcbsoftware.nl/code/mu/mu4e/index.html#Top][mue4 manual]] and [[http://www.djcbsoftware.nl/code/mu/mu4e/Example-configurations.html#Example-configurations][example configurations]] for details.

#+BEGIN_SRC emacs-lisp
  (when (executable-find "mu")
    (autoload 'mu4e "mu4e" "Read your mail." t)
    (with-eval-after-load "mu4e"
      (require 'mu4e)
      (require 'mu4e-headers)
      (setq mu4e-headers-include-related t
            mu4e-headers-skip-duplicates t
            ;; don't keep message buffers around
            message-kill-buffer-on-exit t
            ;; enable notifications
            mu4e-enable-mode-line t
            mu4e-headers-fields '(
                                  (:human-date . 12)
                                  (:flags . 6)
                                  ;; (:mailing-list . 10)
                                  (:from-or-to . 22)
                                  (:subject)))
      ;; ;; use org for composing rich text emails
      ;; (require 'org-mu4e)
      ;; (setq org-mu4e-convert-to-html t)
      ;; (define-key mu4e-headers-mode-map (kbd "C-c c") 'org-mu4e-store-and-capture)
      ;; (define-key mu4e-view-mode-map    (kbd "C-c c") 'org-mu4e-store-and-capture)
      ;; ;; re
      nder html
      (require 'mu4e-contrib)
      (setq mu4e-html2text-command 'mu4e-shr2text)
      (add-hook 'mu4e-view-mode-hook 'visual-line-mode)))
#+END_SRC

*** File browsing (Dired+)
    :PROPERTIES:
    :CUSTOM_ID: file-browsing
    :END:
Emacs makes a decent file browser, we just need to tweak a few things to make it nicer. In particular you can open files in an external program using the =E= key.

#+BEGIN_SRC emacs-lisp
  ;;; Dired and Dired+ configuration
  (add-hook 'dired-mode-hook 
            (lambda()
              (diff-hl-dired-mode)
              (diff-hl-margin-mode)))

  ;; show details by default
  (setq diredp-hide-details-initially-flag nil)

  ;; set dired listing options
  (if (eq system-type 'gnu/linux)
      (setq dired-listing-switches "-alDhp"))

  ;; make sure dired buffers end in a slash so we can identify them easily
  (defun ensure-buffer-name-ends-in-slash ()
    "change buffer name to end with slash"
    (let ((name (buffer-name)))
      (if (not (string-match "/$" name))
          (rename-buffer (concat name "/") t))))
  (add-hook 'dired-mode-hook 'ensure-buffer-name-ends-in-slash)
  (add-hook 'dired-mode-hook
            (lambda()
               (setq truncate-lines 1)))

  ;; open files in external programs
  ;; (from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
  ;; consider replacing with https://github.com/thamer/runner
  (defun xah-open-in-external-app (&optional file)
    "Open the current file or dired marked files in external app.

  The app is chosen from your OS's preference."
    (interactive)
    (let (doIt
          (myFileList
           (cond
            ((string-equal major-mode "dired-mode")
             (dired-get-marked-files))
            ((not file) (list (buffer-file-name)))
            (file (list file)))))
      (setq doIt (if (<= (length myFileList) 5)
                     t
                   (y-or-n-p "Open more than 5 files? "))) 
      (when doIt
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (fPath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)))
           myFileList))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (fPath)
             (shell-command (format "open \"%s\"" fPath)))
           myFileList))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (fPath)
             (let ((process-connection-type nil))
               (start-process "" nil "xdg-open" fPath))) myFileList))))))
  ;; use zip/unzip to compress/uncompress zip archives
  (with-eval-after-load "dired-aux"
    (add-to-list 'dired-compress-file-suffixes 
                 '("\\.zip\\'" "" "unzip"))
    ;; open files from dired with "E"
    (define-key dired-mode-map (kbd "E") 'xah-open-in-external-app))
#+END_SRC

*** Shell modes (term, shell and eshell)
    :PROPERTIES:
    :CUSTOM_ID: shell-modes
    :END:
There are several different shells available in Emacs by default. In addition =multi-term= is available to give you a nicer way of running your default shell in Emacs. Convenience functions are enabled to set your EDITOR variable so that Emacs will be used as your editor when running shell commands inside Emacs. 

#+BEGIN_SRC emacs-lisp
  ;; term
  (with-eval-after-load "term"
    (define-key term-mode-map (kbd "C-j") 'term-char-mode)
    (define-key term-raw-map (kbd "C-j") 'term-line-mode))

  ;; multi-term
  (defalias 'terminal 'multi-term)
  (with-eval-after-load "multi-term"
    (define-key term-mode-map (kbd "C-j") 'term-char-mode)
    (define-key term-raw-map (kbd "C-j") 'term-line-mode))

  ;; shell
  (require 'essh) ; if not done elsewhere; essh is in the local lisp folder
  (require 'eval-in-repl-shell)
  (with-eval-after-load "sh-script"
    (define-key sh-mode-map "\C-c\C-c" 'eir-eval-in-shell)
    (define-key sh-mode-map (kbd "<C-return>") 'eir-eval-in-shell)
    (define-key sh-mode-map (kbd "<C-S-return>") 'executable-interpret))

  ;; Automatically adjust output width in commint buffers
  ;; from http://stackoverflow.com/questions/7987494/emacs-shell-mode-display-is-too-wide-after-splitting-window
  (defun comint-fix-window-size ()
    "Change process window size."
    (when (derived-mode-p 'comint-mode)
      (let ((process (get-buffer-process (current-buffer))))
        (unless (eq nil process)
          (set-process-window-size process (window-height) (window-width))))))

  (defun my-shell-mode-hook ()
    ;; add this hook as buffer local, so it runs once per window.
    (add-hook 'window-configuration-change-hook 'comint-fix-window-size nil t))

  (add-hook 'shell-mode-hook
            (lambda()
              ;; add this hook as buffer local, so it runs once per window.
              (add-hook 'window-configuration-change-hook 'comint-fix-window-size nil t)))

  ;; extra completion for eshell
  (add-hook 'eshell-mode-hook
            (lambda()
              ;; programs that don't work well in eshell and should be run in visual mode
              (add-to-list 'eshell-visual-commands "ssh")
              (add-to-list 'eshell-visual-commands "tail")
              (add-to-list 'eshell-visual-commands "htop")
              (setq eshell-visual-subcommands '(("git" "log" "diff" "show")))))

  ;; Use emacs as editor when running external processes or using shells in emacs
  (when (and (string-match-p "remacs" (prin1-to-string (frame-list)))
             (executable-find "remacsclient"))
    (setq with-editor-emacsclient-executable (executable-find "remacsclient")))

  (require 'with-editor)
  (add-hook 'shell-mode-hook
            (lambda()
              (with-editor-export-editor)
              (with-editor-export-git-editor)
              (sleep-for 0.5) ; this is bad, but thinking hurts and it works.
              (call-interactively 'comint-clear-buffer)))
  (add-hook 'term-exec-hook
            (lambda()
              (with-editor-export-editor)
              (with-editor-export-git-editor)
              (sleep-for 0.5) ; see comment above
              (call-interactively 'comint-clear-buffer)))
  (add-hook 'eshell-mode-hook
            (lambda()
              (with-editor-export-editor)
              (with-editor-export-git-editor)))

  (shell-command-with-editor-mode t)
  (require 'git-commit)
#+END_SRC

** Demonstration tools (command-log-mode)

=command-log-mode= is useful for giving emacs demonstrations/tutorials. It shows the keys you've pressed and the commands they called. More information is available at https://github.com/lewang/command-log-mode.

#+BEGIN_SRC emacs-lisp
  (setq command-log-mode-auto-show t)
  (global-set-key (kbd "C-x cl") 'global-command-log-mode)
#+END_SRC

** Final touches
This Emacs configuration sets up lots of packages and configures a number of keybindings. To add our own customizations, place them in =~/.emacs.d/custom.el=. This file will be sourced last, so you always have the ability to override any settings provided here.

#+BEGIN_SRC emacs-lisp
  ;; save settings made using the customize interface to a sparate file
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (unless (file-exists-p custom-file)
    (write-region ";; Put user configuration here" nil custom-file))
  (load custom-file 'noerror)

  ;; ;; clean up the mode line
  ; (require 'diminish)
  (diminish 'visual-line-mode)
  (diminish 'which-key-mode)
  (diminish 'smooth-scroll-mode)
  ;; (diminish 'company-mode "comp")
  ;; (diminish 'outline-minor-mode "outline")
  ;; (diminish 'undo-tree-mode)
  

  ;; No, we do not need the splash screen
  (setq inhibit-startup-screen t)

  ;; start with untitled new buffer
  (add-hook 'after-init-hook
            '(lambda()
                   (untitled-new-buffer-with-select-major-mode 'text-mode)))

  (setq untitled-new-buffer-major-modes '(text-mode emacs-lisp-mode))
  ;; Change default buffer name.
  (setq untitled-new-buffer-default-name "Untitled")

#+END_SRC

* Concluding remarks

That's all folks, report any bugs or feature requests at [[https://github.com/izahn/dotemacs]].
